# QtBaroboLink a.k.a. BaroboLink 2
# Barobo, Inc.

cmake_minimum_required(VERSION 2.8.9)
cmake_policy(VERSION 2.8.9)
#cmake_policy(SET CMP0020 OLD) # we'll link with QTMAIN manually

project(QtBaroboLink)

set(VERSION_MAJOR 2)
set(VERSION_MINOR 0)
set(VERSION_PATCH 1)
set(VERSION ${VERSION_MAJOR}.${VERSION_MINOR}.${VERSION_PATCH})

##############################################################################
# Setup

# Since this is an executable project, we want all shared libraries generated
# by subprojects to be deposited in our own binary directory. This allows us
# to run our executable immediately after compilation, without copying
# libraries around.
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

# Same rationale as above; on DLL platforms, DLLs are runtime targets. This
# means that any other executables generated by subprojects (demos, etc.) will
# also be deposited in our binary directory.
set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR})

add_subdirectory(../libbarobo libbarobo)

set(CMAKE_MODULE_PATH 
    ${CMAKE_MODULE_PATH}
    $ENV{QTDIR}lib/cmake/Qt5
   )
find_package(Qt5Core REQUIRED)
find_package(Qt5Widgets REQUIRED)

set(DEF_INSTALL_BIN_DIR bin)
set(DEF_INSTALL_SHARE_DIR share/${PROJECT_NAME})

set(INSTALL_BIN_DIR ${DEF_INSTALL_BIN_DIR}
  CACHE PATH "binary installation directory")
set(INSTALL_SHARE_DIR ${DEF_INSTALL_SHARE_DIR}
  CACHE PATH "data installation directory")

message(STATUS "${PROJECT_NAME} will install binaries to ${CMAKE_INSTALL_PREFIX}/${INSTALL_BIN_DIR}")
message(STATUS "${PROJECT_NAME} will install data to ${CMAKE_INSTALL_PREFIX}/${INSTALL_SHARE_DIR}")

##############################################################################
# Content

#install(DIRECTORY html DESTINATION ${INSTALL_SHARE_DIR})

set(CMAKE_INCLUDE_CURRENT_DIR ON)
set(CMAKE_AUTOMOC ON)

include_directories(${LIBBAROBO_INCLUDE_DIRS} ${PROJECT_SOURCE_DIR}/inc ${PROJECT_BINARY_DIR})

# Using gnu++11 instead of c++11 to workaround off64_t issue in late versions
# of MinGW: http://sourceforge.net/p/mingw/bugs/2024
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=gnu++11")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -DQT_NO_DEBUG_OUTPUT")

##############################################################################
# Targets

set(TARGET QtBaroboLink)

qt5_add_resources(RESOURCES resource.qrc)

set(SOURCES
    src/asyncrobot.cpp
    src/configfile.cpp
    src/connectdialog.cpp
    src/controlpanel.cpp
    src/main.cpp
    src/mainwindow.cpp
    src/qtrobotmanager.cpp
    src/recordmobot.cpp
    src/robotmanager.cpp
    src/scandialog.cpp
    src/scanlist.cpp
    src/tcpcomms.cpp
    src/QMobot.cpp
    src/auxcontrolpanel.cpp
   )

qt5_wrap_cpp(HEADERS
    inc/asyncrobot.h
    inc/connectdialog.h
    inc/controlpanel.h
    inc/mainwindow.h
    inc/qtrobotmanager.h
    inc/scandialog.h
    inc/scanlist.h
    inc/tcpcomms.h
    inc/QMobot.h
    inc/auxcontrolpanel.h
   )

qt5_wrap_ui(UIFILES
    connectpanel.ui
    controlpanel.ui
    mainwindow.ui
    scandialog.ui
    scanwidget.ui
    auxcontrol.ui
   )

ADD_DEFINITIONS(${QT_DEFINITIONS})

add_executable(${TARGET} ${SOURCES} ${HEADERS} ${UIFILES} ${RESOURCES})

# FIXME when it becomes feasible to require CMake >= 2.8.11, remove this crap
# search on the internet for "CMake policy CMP0020" to read why
set(QTMAIN)
if(WIN32)
  set(QTMAIN Qt5::WinMain) # imported from Qt5Core
endif()

target_link_libraries(${TARGET} ${LIBBAROBO_LIBRARIES} ${QTMAIN})
qt5_use_modules(${TARGET} Widgets Network WebKitWidgets)

install(TARGETS ${TARGET} RUNTIME DESTINATION ${INSTALL_BIN_DIR})

if(APPLE)
  # Qt5 headers won't compile without the following...
  set_target_properties(${TARGET} PROPERTIES COMPILE_FLAGS "-mmacosx-version-min=10.7 -stdlib=libc++")
  set_target_properties(${TARGET} PROPERTIES LINK_FLAGS "-mmacosx-version-min=10.7 -stdlib=libc++")
endif()

# Include required libraries at install-time. This is the Windows way.
if(WIN32)
  # The application we'll be fixing up is the main target executable.
  # Note the "\$" here. When the install code below is executed, we want the
  # CMAKE_INSTALL_PREFIX as set at install time, not as set right now. These
  # would be different in the case of CPack, which sets its own install
  # prefix.
  set(APPS "\${CMAKE_INSTALL_PREFIX}/${INSTALL_BIN_DIR}/${TARGET}${CMAKE_EXECUTABLE_SUFFIX}")

  # At the moment, fixup_bundle seems to be detecting required plugins. If we
  # needed to manually specify plugins, I think they would go here.
  set(LIBS)

  # If we need to manually specify library search paths, they would go here.
  set(DIRS)

  # So, gp_cmd_paths ...
  # fixup_bundle calls get_prerequisites (GetPrerequisites.cmake) to enumerate
  # all DLL dependencies for the given ${APPS}. get_prerequisites depends on
  # an external tool (ldd, otool, dumpbin, or objdump) to figure out this
  # info. Under Windows, our two options are dumpbin (provided by MS Visual
  # Studio) and objdump (provided by MinGW). get_prerequisites is already
  # disgustingly inefficient, and objdump exacerbates this problem by being
  # both a memory hog and itself disgustingly inefficient (or at least, the
  # way get_prerequisites uses it is inefficient--I haven't looked too hard).
  # For very simple applications it will work, but for a Qt application, my
  # VM ran out of memory before completing fixup_bundle. So, fuck that. We
  # need to use dumpbin.
  #
  # Now, dumpbin lives in <path to Visual Studio>\VC\bin.
  # GetPrerequisites.cmake has some paths to older versions of Visual Studio
  # hardcoded in, but it lacks the path to 10.0. (There is an overarching
  # CMake issue, in my opinion, that there is no FindMSVC.cmake module, which
  # would obviate the need for hardcoding that crap, but that's beside the
  # point.) Our options are limited:
  # 1) require the builder to hack the MSVC path into
  #    <path to CMake modules>\GetPrerequisites.cmake. This would mean
  #    modifying CMake's default install, which is pretty tacky.
  # 2) require the builder to add the MSVC path to the PATH environment
  #    variable. But the MinGW PATH has enough problems as it is, I'd like to
  #    avoid making them worse inadvertantly.
  # 3) Set gp_cmd_paths ahead of time (get_prerequisites only appends to the
  #    list, it doesn't obliterate it). This is what I'm doing here.
  #
  # Long-term fix: write my own FindMSVC.cmake module and programmatically set
  # gp_cmd_paths from its output.
  # Longer-term fix: fix GetPrerequisites.cmake. This is ridiculous.
  #
  # NOTE: You will probably need to add "<path to VS>/Common7/IDE" to your
  # path, otherwise link.exe will fail with a missing DLL.
  install(CODE "
    include(BundleUtilities)
    set(gp_cmd_paths \${gp_cmd_paths}
      \"C:/Program Files/Microsoft Visual Studio 10.0/VC/bin\"
      \"C:/Program Files (x86)/Microsoft Visual Studio 10.0/VC/bin\")
    fixup_bundle(\"${APPS}\" \"${LIBS}\" \"${DIRS}\")")
endif()

##############################################################################

if(CMAKE_SYSTEM_NAME MATCHES [Ll]inux)
  string(TOLOWER "${CPACK_PACKAGE_NAME}" CPACK_PACKAGE_NAME_LOWERCASE)
  find_program(DPKG_PROGRAM dpkg DOC "dpkg program of Debian-based systems")
  if(DPKG_PROGRAM)
       execute_process(COMMAND ${DPKG_PROGRAM} --print-architecture
                 OUTPUT_VARIABLE CPACK_DEBIAN_PACKAGE_ARCHITECTURE
                 OUTPUT_STRIP_TRAILING_WHITESPACE)
       set(CPACK_PACKAGE_FILE_NAME "${CPACK_PACKAGE_NAME_LOWERCASE}_${PROJECT_VERSION}-${CPACK_DEBIAN_PACKAGE_REVISION}_${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}") 
  else(DPKG_PROGRAM)
       set(CPACK_PACKAGE_FILE_NAME "${CPACK_PACKAGE_NAME_LOWERCASE}_${PROJECT_VERSION}-${CPACK_DEBIAN_PACKAGE_REVISION}_${CMAKE_SYSTEM_NAME}")
  endif(DPKG_PROGRAM)

  include(InstallRequiredSystemLibraries)

  set(CPACK_SET_DESTDIR "on")
  set(CPACK_PACKAGE_NAME "BaroboLink")
  set(CPACK_PACKAGING_INSTALL_PREFIX "/tmp")
  set(CPACK_GENERATOR "DEB")

  set(VERSION 1.5.5)
  set(CPACK_DEBIAN_PACKAGE_VERSION ${VERSION})
  set(CPACK_DEBIAN_PACKAGE_PRIORITY "optional")
  set(CPACK_DEBIAN_PACKAGE_SECTION "Science & Engineering")
  set(CPACK_DEBIAN_ARCHITECTURE ${CMAKE_SYSTEM_PROCESSOR})
#SET (CPACK_DEBIAN_PACKAGE_DEPENDS "libc6, libgladeui-1-11, libglib2.0-0, libgtk2.0-0")
  set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)

  set(CPACK_PACKAGE_DESCRIPTION "Barobo Robot Controller")
  set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Graphical Interface for controlling, programming, and interacting with Barobo Mobots and Linkbots.")
  set(CPACK_PACKAGE_CONTACT "david@barobo.com")
  set(CPACK_DEBIAN_PACKAGE_MAINTAINER "David Ko <david@barobo.com>")
  set(CPACK_PACKAGE_FILE_NAME "${CMAKE_PROJECT_NAME}_${VERSION}_${CPACK_DEBIAN_PACKAGE_ARCHITECTURE}")

  set(CPACK_COMPONENTS_ALL Libraries ApplicationData)
  include(CPack)
else()
  include(InstallRequiredSystemLibraries)
  set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "BaroboLink")
  set(CPACK_PACKAGE_NAME "BaroboLink")
  set(CPACK_PACKAGE_VENDOR "Barobo, inc.")
#set(CPACK_PACKAGE_DESCRIPTION_FILE "${CMAKE_CURRENT_SOURCE_DIR}/ReadMe.txt")
#set(CPACK_RESOURCE_FILE_LICENSE "${CMAKE_CURRENT_SOURCE_DIR}/Copyright.txt")
  set(CPACK_PACKAGE_VERSION_MAJOR ${VERSION_MAJOR})
  set(CPACK_PACKAGE_VERSION_MINOR ${VERSION_MINOR})
  set(CPACK_PACKAGE_VERSION_PATCH ${VERSION_PATCH})
  set(CPACK_PACKAGE_INSTALL_DIRECTORY "BaroboLink ${VERSION}")
  if(WIN32 AND NOT UNIX)
    # There is a bug in NSI that does not handle full unix paths properly. Make
    # sure there is at least one set of four (4) backlasshes.
    #set(CPACK_PACKAGE_ICON "${CMake_SOURCE_DIR}/Utilities/Release\\\\InstallIcon.bmp")
    #set(CPACK_NSIS_INSTALLED_ICON_NAME "bin\\\\MyExecutable.exe")
    set(CPACK_NSIS_DISPLAY_NAME "BaroboLink ${VERSION}")
    set(CPACK_NSIS_HELP_LINK "http://www.barobo.com")
    set(CPACK_NSIS_URL_INFO_ABOUT "http://www.barobo.com")
    set(CPACK_NSIS_CONTACT "david@barobo.com")
    set(CPACK_NSIS_MODIFY_PATH ON)
  else(WIN32 AND NOT UNIX)
    #set(CPACK_STRIP_FILES "bin/MyExecutable")
    #set(CPACK_SOURCE_STRIP_FILES "")
  endif(WIN32 AND NOT UNIX)
  set(CPACK_PACKAGE_EXECUTABLES "${TARGET}" "BaroboLink")
  include(CPack)
endif()
